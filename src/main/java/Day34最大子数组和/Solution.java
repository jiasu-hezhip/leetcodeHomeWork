package Day34最大子数组和;

public class Solution {

    /**
     * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
     *
     * 子数组 是数组中的一个连续部分。
     *
     * 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
     * 输出：6
     * 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
     *
     * 输入：nums = [1]
     * 输出：1
     *
     * 输入：nums = [5,4,-1,7,8]
     * 输出：23
     *
     * ！！！其实看到最大值应该立刻想到动态规划，但是耐不住暴力解法太简单了
     * 循环每个元素 -》 每个元素依次累加到最后 -》 放入一个列表 -》排序
     *
     * 动态规划：
     *      动态规划的解题思路是状态定义-》状态转移方程-》初始化-》输出
     *      在本题中，如果以每个元素以及其后方所有元素来定义则找不到状态转移的联系
     *      所以更改方向，使用以每个元素为结尾的前方元素和做状态转移（无后效性）
     *      1。状态定义
     *          新建一个数组用来表示以对应下标为重点的前方元素的和
     *      2。状态转移方程
     *          每一次添加新值都是在上一个最大和的基础上添加
     *          如果nums全都为正则在前一个最大和的基础上相加就可以
     *          如果前一位最大和出现了负数，那么就对比nums[i]的这一位谁更小
     *          所以最大和数组的每一位要么等于前一位加上给定数组的这一位，要么直接等于给定数组的这一位
     *          公式化表达： res[i] = Math.max(res[i-1] + nums[i] , nums[i])
     *
     *
     * 一定要能理解无后效性是什么意思，这是动态规划的重点
     *
     *
     *
     * @param args
     */

    public static void main(String[] args) {
        int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
        System.out.println(maxSubArray(nums));
    }

    public static int maxSubArray(int[] nums) {
        int pre = 0; // 初始化第一个标记位
        int res = nums[0]; // 初始化第一个结果
        for (int num : nums) { // 从数组的0位开始
            pre = Math.max(pre + num, num); // 前一位加上自己和自己谁大？大的就保留下来，作为当前位的结果
            res = Math.max(res, pre);// 比较上一位的结果和当前的结果，只保留最大值
        }
        return res;
    }


}
